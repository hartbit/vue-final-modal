{"version":3,"file":"VueFinalModal.esm.js","sources":["../lib/utils/focusTrap.js","../lib/utils/dragResize.js","../lib/utils/bodyScrollLock.js","../lib/VueFinalModal.vue","../lib/VueFinalModal.vue?vue&type=template&id=2836fdb5&lang.js","../node_modules/style-inject/dist/style-inject.es.js","../lib/ModalsContainer.vue","../lib/ModalsContainer.vue?vue&type=template&id=74d49173&lang.js","../lib/PluginCore.js","../lib/Plugin.js"],"sourcesContent":["// stolen from vue-js-modal\n\nconst FOCUSABLE_ELEMENTS_QUERY =\n  'button:not([disabled]), ' +\n  'select:not([disabled]), ' +\n  'a[href]:not([disabled]), ' +\n  'area[href]:not([disabled]), ' +\n  '[contentEditable=\"\"]:not([disabled]), ' +\n  '[contentEditable=\"true\"]:not([disabled]), ' +\n  '[contentEditable=\"TRUE\"]:not([disabled]), ' +\n  'textarea:not([disabled]), ' +\n  'iframe:not([disabled]), ' +\n  'input:not([disabled]), ' +\n  'summary:not([disabled]), ' +\n  '[tabindex]:not([tabindex=\"-1\"])'\n\nconst isTabPressed = event => {\n  return event.key === 'Tab' || event.keyCode === 9\n}\n\nconst querySelectorAll = (element, selector) => {\n  return [...(element.querySelectorAll(selector) || [])]\n}\n\nconst queryFocusableElements = element => {\n  return querySelectorAll(element, FOCUSABLE_ELEMENTS_QUERY)\n}\n\nconst isFocused = element => {\n  return element == document.activeElement\n}\n\nconst isNothingFocused = () => {\n  return !document.activeElement\n}\n\nclass FocusTrap {\n  constructor() {\n    this.root = null\n    this.elements = []\n\n    this.onKeyDown = this.onKeyDown.bind(this)\n    this.enable = this.enable.bind(this)\n    this.disable = this.disable.bind(this)\n    this.firstElement = this.firstElement.bind(this)\n    this.lastElement = this.lastElement.bind(this)\n  }\n\n  lastElement() {\n    return this.elements[this.elements.length - 1] || null\n  }\n\n  firstElement() {\n    return this.elements[0] || null\n  }\n\n  onKeyDown(event) {\n    if (!isTabPressed(event)) {\n      return\n    }\n\n    // SHIFT + TAB\n    if (event.shiftKey) {\n      if (isFocused(this.firstElement())) {\n        this.lastElement().focus()\n        event.preventDefault()\n      }\n      return\n    }\n\n    // TAB\n    if (isNothingFocused() || isFocused(this.lastElement())) {\n      this.firstElement().focus()\n      event.preventDefault()\n      return\n    }\n  }\n\n  enabled() {\n    return !!this.root\n  }\n\n  enable(root) {\n    if (!root) {\n      return\n    }\n\n    this.root = root\n    this.elements = queryFocusableElements(this.root)\n\n    this.root.addEventListener('keydown', this.onKeyDown)\n  }\n\n  disable() {\n    this.root.removeEventListener('keydown', this.onKeyDown)\n    this.root = null\n  }\n}\n\nexport default FocusTrap\n","export const setStyle = (el, key, value) => {\n  const cacheStyle = el.style[key]\n  el.style[key] = value\n  return () => {\n    el.style[key] = cacheStyle\n  }\n}\n\nexport const getPosition = e => {\n  const { clientX: x, clientY: y } = e.targetTouches ? e.targetTouches[0] : e\n  return { x, y }\n}\n\nexport const capitalize = s => {\n  return s.charAt(0).toUpperCase() + s.slice(1)\n}\n\nexport const clamp = (min, num, max) => {\n  if (typeof min !== 'number') {\n    min = Math.min(num, max) || num\n  }\n  if (typeof max !== 'number') {\n    max = Math.max(num, min)\n  }\n  return Math.min(Math.max(num, min), max)\n}\n\nexport const trimPx = distance => {\n  return (distance && Number(distance.replace(/px$/, ''))) || 0\n}\n\nexport const validDragElement = (e, el, dragSelector) => {\n  if (dragSelector === '') return true\n  const list = [...el.querySelectorAll(dragSelector)]\n  return list.includes(e.target)\n}\n\nconst pointerType = {\n  down: {\n    pc: 'mousedown',\n    m: 'touchstart'\n  },\n  move: {\n    pc: 'mousemove',\n    m: 'touchmove'\n  },\n  up: {\n    pc: 'mouseup',\n    m: 'touchend'\n  }\n}\nexport const addListener = (type, el, callback) => {\n  el && el.addEventListener(pointerType[type].pc, callback)\n  el && el.addEventListener(pointerType[type].m, callback, { passive: false })\n}\nexport const removeListener = (type, el, callback) => {\n  el && el.removeEventListener(pointerType[type].pc, callback)\n  el && el.removeEventListener(pointerType[type].m, callback)\n}\n","// stolen from body-scroll-lock\n\n// Older browsers don't support event options, feature detect it.\nlet hasPassiveEvents = false\nif (typeof window !== 'undefined') {\n  const passiveTestOptions = {\n    get passive() {\n      hasPassiveEvents = true\n      return undefined\n    },\n  }\n  window.addEventListener('testPassive', null, passiveTestOptions)\n  window.removeEventListener('testPassive', null, passiveTestOptions)\n}\n\nconst isIosDevice =\n  typeof window !== 'undefined' &&\n  window.navigator &&\n  window.navigator.platform &&\n  (/iP(ad|hone|od)/.test(window.navigator.platform) ||\n    (window.navigator.platform === 'MacIntel' && window.navigator.maxTouchPoints > 1))\n\nlet locks = []\nlet documentListenerAdded = false\nlet clientY = 0\nlet initialClientY = -1\nlet previousBodyOverflowSetting\nlet previousBodyPaddingRight\n\nconst hasScrollbar = el => {\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return false\n\n  const style = window.getComputedStyle(el)\n  return ['auto', 'scroll'].includes(style.overflowY) && el.scrollHeight > el.clientHeight\n}\n\nconst shouldScroll = (el, delta) => {\n  if (el.scrollTop === 0 && delta < 0) return false\n  if (el.scrollTop + el.clientHeight + delta >= el.scrollHeight && delta > 0) return false\n  return true\n}\n\nconst composedPath = el => {\n  const path = []\n  while (el) {\n    path.push(el)\n    if (el.classList.contains('vfm')) return path\n    el = el.parentElement\n  }\n  return path\n}\n\nconst hasAnyScrollableEl = (el, delta) => {\n  let hasAnyScrollableEl = false\n  const path = composedPath(el)\n  path.forEach(el => {\n    if (hasScrollbar(el) && shouldScroll(el, delta)) {\n      hasAnyScrollableEl = true\n    }\n  })\n  return hasAnyScrollableEl\n}\n\n// returns true if `el` should be allowed to receive touchmove events.\nconst allowTouchMove = el => locks.some(() => hasAnyScrollableEl(el, -clientY))\n\nconst preventDefault = rawEvent => {\n  const e = rawEvent || window.event\n\n  // For the case whereby consumers adds a touchmove event listener to document.\n  // Recall that we do document.addEventListener('touchmove', preventDefault, { passive: false })\n  // in disableBodyScroll - so if we provide this opportunity to allowTouchMove, then\n  // the touchmove event on document will break.\n  if (allowTouchMove(e.target)) {\n    return true\n  }\n  // Do not prevent if the event has more than one touch (usually meaning this is a multi touch gesture like pinch to zoom).\n  if (e.touches.length > 1) return true\n\n  if (e.preventDefault) e.preventDefault()\n\n  return false\n}\n\nconst setOverflowHidden = options => {\n  // If previousBodyPaddingRight is already set, don't set it again.\n  if (previousBodyPaddingRight === undefined) {\n    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true\n    const scrollBarGap = window.innerWidth - document.documentElement.clientWidth\n\n    if (reserveScrollBarGap && scrollBarGap > 0) {\n      const computedBodyPaddingRight = parseInt(getComputedStyle(document.body).getPropertyValue('padding-right'), 10)\n      previousBodyPaddingRight = document.body.style.paddingRight\n      document.body.style.paddingRight = `${computedBodyPaddingRight + scrollBarGap}px`\n    }\n  }\n  // If previousBodyOverflowSetting is already set, don't set it again.\n  if (previousBodyOverflowSetting === undefined) {\n    previousBodyOverflowSetting = document.body.style.overflow\n    document.body.style.overflow = 'hidden'\n  }\n}\n\nconst restoreOverflowSetting = () => {\n  if (previousBodyPaddingRight !== undefined) {\n    document.body.style.paddingRight = previousBodyPaddingRight\n\n    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows it\n    // can be set again.\n    previousBodyPaddingRight = undefined\n  }\n\n  if (previousBodyOverflowSetting !== undefined) {\n    document.body.style.overflow = previousBodyOverflowSetting\n\n    // Restore previousBodyOverflowSetting to undefined\n    // so setOverflowHidden knows it can be set again.\n    previousBodyOverflowSetting = undefined\n  }\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight#Problems_and_solutions\nconst isTargetElementTotallyScrolled = targetElement =>\n  targetElement ? targetElement.scrollHeight - targetElement.scrollTop <= targetElement.clientHeight : false\n\nconst handleScroll = (event, targetElement) => {\n  clientY = event.targetTouches[0].clientY - initialClientY\n\n  if (allowTouchMove(event.target)) {\n    return false\n  }\n\n  if (targetElement && targetElement.scrollTop === 0 && clientY > 0) {\n    // element is at the top of its scroll.\n    return preventDefault(event)\n  }\n\n  if (isTargetElementTotallyScrolled(targetElement) && clientY < 0) {\n    // element is at the bottom of its scroll.\n    return preventDefault(event)\n  }\n\n  event.stopPropagation()\n  return true\n}\n\nexport const disableBodyScroll = (targetElement, options) => {\n  // targetElement must be provided\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices.'\n    )\n    return\n  }\n\n  // disableBodyScroll must not have been called on this targetElement before\n  if (locks.some(lock => lock.targetElement === targetElement)) {\n    return\n  }\n\n  const lock = {\n    targetElement,\n    options: options || {},\n  }\n\n  locks = [...locks, lock]\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        initialClientY = event.targetTouches[0].clientY\n      }\n    }\n    targetElement.ontouchmove = event => {\n      if (event.targetTouches.length === 1) {\n        // detect single touch.\n        handleScroll(event, targetElement)\n      }\n    }\n\n    if (!documentListenerAdded) {\n      document.addEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = true\n    }\n  } else {\n    setOverflowHidden(options)\n  }\n}\n\nexport const enableBodyScroll = targetElement => {\n  if (!targetElement) {\n    // eslint-disable-next-line no-console\n    console.error(\n      'enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices. prout'\n    )\n    return\n  }\n\n  locks = locks.filter(lock => lock.targetElement !== targetElement)\n\n  if (isIosDevice) {\n    targetElement.ontouchstart = null\n    targetElement.ontouchmove = null\n\n    if (documentListenerAdded && locks.length === 0) {\n      document.removeEventListener('touchmove', preventDefault, hasPassiveEvents ? { passive: false } : undefined)\n      documentListenerAdded = false\n    }\n  } else if (!locks.length) {\n    restoreOverflowSetting()\n  }\n}\n","<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @mouseup.self=\"onMouseupContainer\"\n        @mousedown.self=\"onMousedown\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"bindContentStyle\"\n          @mousedown=\"onMousedown(null)\"\n        >\n          <slot :params=\"params\" :close=\"() => $emit('update:modelValue', false)\" />\n          <div\n            v-if=\"visibility.resize && visibility.modal\"\n            ref=\"vfmResize\"\n            class=\"vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none\"\n          >\n            <div\n              v-for=\"direction in resizeDirections\"\n              :key=\"direction\"\n              :direction=\"direction\"\n              :class=\"`vfm--resize-${direction}`\"\n              class=\"vfm--absolute vfm--prevent-auto\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\n/* eslint-disable vue/no-mutating-props */\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport {\n  setStyle,\n  getPosition,\n  capitalize,\n  clamp,\n  trimPx,\n  validDragElement,\n  addListener,\n  removeListener\n} from './utils/dragResize.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nconst resizeCursor = {\n  t: 'ns-resize',\n  tr: 'nesw-resize',\n  r: 'ew-resize',\n  br: 'nwse-resize',\n  b: 'ns-resize',\n  bl: 'nesw-resize',\n  l: 'ew-resize',\n  tl: 'nwse-resize'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [Object, Array], default: () => ({}) },\n    overlayStyle: { type: [Object, Array], default: () => ({}) },\n    contentStyle: { type: [Object, Array], default: () => ({}) },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    keepOverlay: { type: Boolean, default: false },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false },\n    fitParent: { type: Boolean, default: true },\n    drag: { type: Boolean, default: false },\n    dragSelector: { type: String, default: '' },\n    keepChangedStyle: { type: Boolean, default: false },\n    resize: {\n      type: Boolean,\n      default: false\n    },\n    resizeDirections: {\n      type: Array,\n      default: () => ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],\n      validator: val =>\n        ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'].filter(value => val.indexOf(value) !== -1).length === val.length\n    },\n    minWidth: { type: Number, default: 0 },\n    minHeight: { type: Number, default: 0 },\n    maxWidth: { type: Number, default: Infinity },\n    maxHeight: { type: Number, default: Infinity }\n  },\n  emits: [\n    'update:modelValue',\n    'click-outside',\n    'before-open',\n    'opened',\n    'before-close',\n    'closed',\n    '_before-open',\n    '_opened',\n    '_closed',\n    'drag:start',\n    'drag:move',\n    'drag:end',\n    'resize:start',\n    'resize:move',\n    'resize:end'\n  ],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmContent = ref(null)\n    const vfmResize = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false,\n      resize: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n    const dragResizeStyle = ref({})\n    const _state = ref(null)\n    const lastMousedownEl = ref(null)\n\n    let resolveToggle = noop\n    let rejectToggle = noop\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    const bindContentStyle = computed(() => {\n      let style = [dragResizeStyle.value]\n      Array.isArray(props.contentStyle) ? style.push(...props.contentStyle) : style.push(props.contentStyle)\n      return style\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            rejectToggle('hide')\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n    watch(\n      () => props.drag,\n      val => {\n        if (visible.value) {\n          val ? addDragDown() : removeDragDown()\n        }\n      }\n    )\n    watch(\n      () => props.resize,\n      val => {\n        if (visible.value) {\n          val ? addResizeDown() : removeResizeDown()\n        }\n      }\n    )\n    watch(\n      () => props.keepChangedStyle,\n      val => {\n        if (!val) {\n          dragResizeStyle.value = {}\n        }\n      }\n    )\n\n    props.api.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = props.api.modals.findIndex(vm => vm.uid === uid)\n\n      props.api.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        vfmResize,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        emit('_before-open', createModalEvent({ type: '_before-open' }))\n        if (emitEvent('before-open', false)) {\n          rejectToggle('show')\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          if (props.attach !== false) {\n            if (root.value) {\n              target.appendChild(root.value)\n            } else {\n              visible.value = true\n              nextTick(() => {\n                mounted()\n              })\n              return\n            }\n          }\n\n          let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            props.api.openedModals.splice(index, 1)\n          }\n          props.api.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = props.api.openedModals.length - 1\n\n          handleLockScroll()\n\n          props.api.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                !vm.props.keepOverlay && (vm.visibility.overlay = false)\n              }\n            })\n\n          visible.value = true\n          startTransitionEnter()\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        props.api.openedModals.splice(index, 1)\n      }\n      if (props.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = props.api.openedModals[props.api.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      props.drag && removeDragDown()\n      props.resize && removeResizeDown()\n      _state.value = null\n\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      props.focusTrap && $focusTrap.enable(vfmContainer.value)\n      props.drag && addDragDown()\n      props.resize && addResizeDown()\n\n      emit('_opened')\n      emit('opened', createModalEvent({ type: 'opened' }))\n      resolveToggle('show')\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n      if (!props.keepChangedStyle) {\n        dragResizeStyle.value = {}\n      }\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('_closed')\n      emit('closed', event)\n      resolveToggle('hide')\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onMousedown(e) {\n      lastMousedownEl.value = e?.target\n    }\n    function onMouseupContainer() {\n      // skip when the lastMousedownEl didn't equal vfmContainer\n      if (lastMousedownEl.value !== vfmContainer.value) return\n      // skip when state equal 'resize:move'\n      if (_state.value === 'resize:move') return\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function emitState(e, state, action) {\n      _state.value = `${state}:${action}`\n      emit(_state.value, e)\n    }\n    function toggle(show, _params) {\n      return new Promise((resolve, reject) => {\n        resolveToggle = res => {\n          resolve(res)\n          resolveToggle = noop\n        }\n        rejectToggle = err => {\n          reject(err)\n          rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !props.modelValue\n        if (value && arguments.length === 2) {\n          params.value = _params\n        }\n        emit('update:modelValue', value)\n      })\n    }\n    function pointerDown(e) {\n      e.stopPropagation()\n      const STATE_RESIZE = 'resize'\n      const STATE_DRAG = 'drag'\n      const direction = e.target.getAttribute('direction')\n      let state\n      if (direction) {\n        state = STATE_RESIZE\n      } else if (validDragElement(e, vfmContent.value, props.dragSelector)) {\n        state = STATE_DRAG\n      } else {\n        return\n      }\n      emitState(e, state, 'start')\n      const down = getPosition(e)\n      const rectContainer = vfmContainer.value.getBoundingClientRect()\n      const rectContent = vfmContent.value.getBoundingClientRect()\n      const isAbsolute = window.getComputedStyle(vfmContent.value).position === 'absolute'\n      const position = {\n        top: trimPx(dragResizeStyle.value.top),\n        left: trimPx(dragResizeStyle.value.left)\n      }\n      const limit = (() => {\n        if (props.fitParent) {\n          const limit = {\n            absolute() {\n              return {\n                minTop: 0,\n                minLeft: 0,\n                maxTop: rectContainer.height - rectContent.height,\n                maxLeft: rectContainer.width - rectContent.width\n              }\n            },\n            relative() {\n              return {\n                minTop: position.top + rectContainer.top - rectContent.top,\n                minLeft: position.left + rectContainer.left - rectContent.left,\n                maxTop: position.top + rectContainer.bottom - rectContent.bottom,\n                maxLeft: position.left + rectContainer.right - rectContent.right\n              }\n            }\n          }\n          return isAbsolute ? limit.absolute() : limit.relative()\n        } else {\n          return {}\n        }\n      })()\n      const resetBodyCursor = state === STATE_RESIZE && setStyle(document.body, 'cursor', resizeCursor[direction])\n\n      const moving = e => {\n        // onPointerMove\n        e.stopPropagation()\n        emitState(e, state, 'move')\n        const move = getPosition(e)\n        let offset = {\n          x: move.x - down.x,\n          y: move.y - down.y\n        }\n        if (state === STATE_RESIZE) {\n          offset = getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute)\n        }\n\n        let top\n        let left\n        if (isAbsolute) {\n          top = rectContent.top - rectContainer.top + offset.y\n          left = rectContent.left - rectContainer.left + offset.x\n        } else {\n          top = position.top + offset.y\n          left = position.left + offset.x\n        }\n        if (state === STATE_DRAG && props.fitParent) {\n          top = clamp(limit.minTop, top, limit.maxTop)\n          left = clamp(limit.minLeft, left, limit.maxLeft)\n        }\n        const style = {\n          position: 'relative',\n          top: top + 'px',\n          left: left + 'px',\n          margin: 'unset',\n          touchAction: 'none',\n          ...(isAbsolute && {\n            position: 'absolute',\n            transform: 'unset',\n            width: rectContent.width + 'px',\n            height: rectContent.height + 'px'\n          }),\n          ...(offset.width && { width: offset.width + 'px' }),\n          ...(offset.height && { height: offset.height + 'px' })\n        }\n\n        dragResizeStyle.value = {\n          ...dragResizeStyle.value,\n          ...style\n        }\n      }\n      const end = e => {\n        // onPointerUp\n        e.stopPropagation()\n        if (state === STATE_RESIZE) {\n          resetBodyCursor && resetBodyCursor()\n        }\n        // Excute onMouseupContainer before trigger emitState\n        setTimeout(() => {\n          emitState(e, state, 'end')\n        })\n        removeListener('move', document, moving)\n        removeListener('up', document, end)\n      }\n      addListener('move', document, moving)\n      addListener('up', document, end)\n    }\n    function addDragDown() {\n      addListener('down', vfmContent.value, pointerDown)\n      dragResizeStyle.value.touchAction = 'none'\n    }\n    function removeDragDown() {\n      removeListener('down', vfmContent.value, pointerDown)\n    }\n    function addResizeDown() {\n      visibility.resize = true\n      nextTick(() => {\n        addListener('down', vfmResize.value, pointerDown)\n      })\n    }\n    function removeResizeDown() {\n      removeListener('down', vfmResize.value, pointerDown)\n      visibility.resize = false\n    }\n    function getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute) {\n      const setOffset = dir => {\n        let offsetAxis = offset[dir.axis]\n        offsetAxis = props.fitParent ? clamp(dir.min, offsetAxis, dir.max) : offsetAxis\n        let edge = clamp(dir.minEdge, dir.getEdge(offsetAxis), dir.maxEdge)\n        offsetAxis = dir.getOffsetAxis(edge, isAbsolute)\n        return {\n          [dir.edgeName]: edge,\n          [dir.axis]: offsetAxis\n        }\n      }\n\n      const getDirectionInfo = (position, edgeName, axis, isPositive) => {\n        const rectContentEdge = rectContent[edgeName]\n        const positionOffset = rectContainer[position] - rectContent[position]\n        const EdgeName = capitalize(edgeName)\n        return {\n          axis,\n          edgeName,\n          min: isPositive ? positionOffset : -rectContentEdge,\n          max: isPositive ? rectContentEdge : positionOffset,\n          minEdge: props[`min${EdgeName}`],\n          maxEdge: props[`max${EdgeName}`],\n          getEdge: offsetAxis => rectContent[edgeName] - offsetAxis * (isPositive ? 1 : -1),\n          getOffsetAxis: (edge, isAbsolute) => {\n            const offsetAxis = rectContent[edgeName] - edge\n            if (isAbsolute) {\n              return isPositive ? offsetAxis : 0\n            } else {\n              return ((isPositive ? 1 : -1) * offsetAxis) / 2\n            }\n          }\n        }\n      }\n\n      const directions = {\n        t: ['top', 'height', 'y', true],\n        b: ['bottom', 'height', 'y', false],\n        l: ['left', 'width', 'x', true],\n        r: ['right', 'width', 'x', false]\n      }\n\n      let _offset = { x: 0, y: 0 }\n      direction.split('').forEach(dir => {\n        const directionInfo = getDirectionInfo(...directions[dir])\n        _offset = {\n          ..._offset,\n          ...setOffset(directionInfo)\n        }\n      })\n      return _offset\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmContent,\n      vfmResize,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      bindContentStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onMousedown,\n      onMouseupContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n\n.vfm--touch-none {\n  touch-action: none;\n}\n.vfm--select-none {\n  user-select: none;\n}\n\n.vfm--resize-tr,\n.vfm--resize-br,\n.vfm--resize-bl,\n.vfm--resize-tl {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n\n.vfm--resize-t {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n</style>\n","<template>\n  <div\n    v-if=\"ssr || visible\"\n    v-show=\"!ssr || visible\"\n    ref=\"root\"\n    :style=\"bindStyle\"\n    class=\"vfm vfm--inset\"\n    :class=\"[attach === false ? 'vfm--fixed' : 'vfm--absolute', { 'vfm--prevent-none': preventClick }]\"\n    @keydown.esc=\"onEsc\"\n  >\n    <transition\n      v-bind=\"computedOverlayTransition\"\n      @before-enter=\"beforeOverlayEnter\"\n      @after-enter=\"afterOverlayEnter\"\n      @before-leave=\"beforeOverlayLeave\"\n      @after-leave=\"afterOverlayLeave\"\n    >\n      <div\n        v-if=\"!hideOverlay && visibility.overlay\"\n        class=\"vfm__overlay vfm--overlay vfm--absolute vfm--inset\"\n        :class=\"overlayClass\"\n        :style=\"overlayStyle\"\n      ></div>\n    </transition>\n    <transition\n      v-bind=\"computedTransition\"\n      @before-enter=\"beforeModalEnter\"\n      @after-enter=\"afterModalEnter\"\n      @before-leave=\"beforeModalLeave\"\n      @after-leave=\"afterModalLeave\"\n    >\n      <div\n        v-show=\"visibility.modal\"\n        ref=\"vfmContainer\"\n        class=\"vfm__container vfm--absolute vfm--inset vfm--outline-none\"\n        :class=\"classes\"\n        :style=\"styles\"\n        :aria-expanded=\"visibility.modal.toString()\"\n        role=\"dialog\"\n        aria-modal=\"true\"\n        tabindex=\"-1\"\n        @mouseup.self=\"onMouseupContainer\"\n        @mousedown.self=\"onMousedown\"\n      >\n        <div\n          ref=\"vfmContent\"\n          class=\"vfm__content\"\n          :class=\"[contentClass, { 'vfm--prevent-auto': preventClick }]\"\n          :style=\"bindContentStyle\"\n          @mousedown=\"onMousedown(null)\"\n        >\n          <slot :params=\"params\" :close=\"() => $emit('update:modelValue', false)\" />\n          <div\n            v-if=\"visibility.resize && visibility.modal\"\n            ref=\"vfmResize\"\n            class=\"vfm__resize vfm--absolute vfm--inset vfm--prevent-none vfm--select-none vfm--touch-none\"\n          >\n            <div\n              v-for=\"direction in resizeDirections\"\n              :key=\"direction\"\n              :direction=\"direction\"\n              :class=\"`vfm--resize-${direction}`\"\n              class=\"vfm--absolute vfm--prevent-auto\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </transition>\n  </div>\n</template>\n\n<script>\n/* eslint-disable vue/no-mutating-props */\nimport { ref, reactive, onMounted, onBeforeUnmount, computed, nextTick, watch } from 'vue'\nimport FocusTrap from './utils/focusTrap.js'\nimport {\n  setStyle,\n  getPosition,\n  capitalize,\n  clamp,\n  trimPx,\n  validDragElement,\n  addListener,\n  removeListener\n} from './utils/dragResize.js'\nimport { disableBodyScroll, enableBodyScroll } from './utils/bodyScrollLock'\n\nconst noop = () => {}\n\nconst TransitionState = {\n  Enter: 'enter',\n  Entering: 'entering',\n  Leave: 'leave',\n  Leaving: 'leavng'\n}\n\nconst resizeCursor = {\n  t: 'ns-resize',\n  tr: 'nesw-resize',\n  r: 'ew-resize',\n  br: 'nwse-resize',\n  b: 'ns-resize',\n  bl: 'nesw-resize',\n  l: 'ew-resize',\n  tl: 'nwse-resize'\n}\n\nexport default {\n  props: {\n    name: { type: String, default: null },\n    modelValue: { type: Boolean, default: false },\n    ssr: { type: Boolean, default: true },\n    classes: { type: [String, Object, Array], default: '' },\n    overlayClass: { type: [String, Object, Array], default: '' },\n    contentClass: { type: [String, Object, Array], default: '' },\n    styles: { type: [Object, Array], default: () => ({}) },\n    overlayStyle: { type: [Object, Array], default: () => ({}) },\n    contentStyle: { type: [Object, Array], default: () => ({}) },\n    lockScroll: { type: Boolean, default: true },\n    hideOverlay: { type: Boolean, default: false },\n    clickToClose: { type: Boolean, default: true },\n    escToClose: { type: Boolean, default: false },\n    preventClick: { type: Boolean, default: false },\n    attach: {\n      type: null,\n      default: false,\n      validator(val) {\n        const type = typeof val\n\n        if (type === 'boolean' || type === 'string') return true\n\n        return val.nodeType === Node.ELEMENT_NODE\n      }\n    },\n    transition: { type: [String, Object], default: 'vfm' },\n    overlayTransition: { type: [String, Object], default: 'vfm' },\n    keepOverlay: { type: Boolean, default: false },\n    zIndexAuto: { type: Boolean, default: true },\n    zIndexBase: { type: [String, Number], default: 1000 },\n    zIndex: { type: [Boolean, String, Number], default: false },\n    focusRetain: { type: Boolean, default: true },\n    focusTrap: { type: Boolean, default: false },\n    fitParent: { type: Boolean, default: true },\n    drag: { type: Boolean, default: false },\n    dragSelector: { type: String, default: '' },\n    keepChangedStyle: { type: Boolean, default: false },\n    resize: {\n      type: Boolean,\n      default: false\n    },\n    resizeDirections: {\n      type: Array,\n      default: () => ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'],\n      validator: val =>\n        ['t', 'tr', 'r', 'br', 'b', 'bl', 'l', 'tl'].filter(value => val.indexOf(value) !== -1).length === val.length\n    },\n    minWidth: { type: Number, default: 0 },\n    minHeight: { type: Number, default: 0 },\n    maxWidth: { type: Number, default: Infinity },\n    maxHeight: { type: Number, default: Infinity }\n  },\n  emits: [\n    'update:modelValue',\n    'click-outside',\n    'before-open',\n    'opened',\n    'before-close',\n    'closed',\n    '_before-open',\n    '_opened',\n    '_closed',\n    'drag:start',\n    'drag:move',\n    'drag:end',\n    'resize:start',\n    'resize:move',\n    'resize:end'\n  ],\n  setup(props, { emit }) {\n    const uid = Symbol('vfm')\n    const root = ref(null)\n    const vfmContainer = ref(null)\n    const vfmContent = ref(null)\n    const vfmResize = ref(null)\n    const vfmOverlayTransition = ref(null)\n    const vfmTransition = ref(null)\n\n    const modalStackIndex = ref(null)\n    const $focusTrap = new FocusTrap()\n\n    const visible = ref(false)\n    const visibility = reactive({\n      modal: false,\n      overlay: false,\n      resize: false\n    })\n    const overlayTransitionState = ref(null)\n    const modalTransitionState = ref(null)\n    const _stopEvent = ref(false)\n    const params = ref({})\n    const dragResizeStyle = ref({})\n    const _state = ref(null)\n    const lastMousedownEl = ref(null)\n\n    let resolveToggle = noop\n    let rejectToggle = noop\n\n    const computedOverlayTransition = computed(() => {\n      if (typeof props.overlayTransition === 'string') return { name: props.overlayTransition }\n      return { ...props.overlayTransition }\n    })\n\n    const computedTransition = computed(() => {\n      if (typeof props.transition === 'string') return { name: props.transition }\n      return { ...props.transition }\n    })\n\n    const isComponentReadyToBeDestroyed = computed(() => {\n      return (\n        (props.hideOverlay || overlayTransitionState.value === TransitionState.Leave) &&\n        modalTransitionState.value === TransitionState.Leave\n      )\n    })\n\n    const calculateZIndex = computed(() => {\n      if (props.zIndex === false) {\n        if (props.zIndexAuto) {\n          return +props.zIndexBase + 2 * (modalStackIndex.value || 0)\n        } else {\n          return false\n        }\n      } else {\n        return props.zIndex\n      }\n    })\n\n    const bindStyle = computed(() => {\n      return {\n        ...(calculateZIndex.value !== false && {\n          zIndex: calculateZIndex.value\n        })\n      }\n    })\n\n    const bindContentStyle = computed(() => {\n      let style = [dragResizeStyle.value]\n      Array.isArray(props.contentStyle) ? style.push(...props.contentStyle) : style.push(props.contentStyle)\n      return style\n    })\n\n    watch(\n      () => props.modelValue,\n      value => {\n        if (_stopEvent.value) {\n          _stopEvent.value = false\n          return\n        }\n        mounted()\n        if (!value) {\n          if (emitEvent('before-close', true)) {\n            rejectToggle('hide')\n            return\n          }\n          close()\n        }\n      }\n    )\n    watch(() => props.lockScroll, handleLockScroll)\n    watch(\n      () => props.hideOverlay,\n      value => {\n        if (props.modelValue && !value) {\n          visibility.overlay = true\n        }\n      }\n    )\n    watch(() => props.attach, mounted)\n    watch(\n      isComponentReadyToBeDestroyed,\n      val => {\n        if (val) {\n          visible.value = false\n          vfmContainer.value.style.display = 'none'\n        }\n      },\n      {\n        flush: 'post'\n      }\n    )\n    watch(\n      () => props.drag,\n      val => {\n        if (visible.value) {\n          val ? addDragDown() : removeDragDown()\n        }\n      }\n    )\n    watch(\n      () => props.resize,\n      val => {\n        if (visible.value) {\n          val ? addResizeDown() : removeResizeDown()\n        }\n      }\n    )\n    watch(\n      () => props.keepChangedStyle,\n      val => {\n        if (!val) {\n          dragResizeStyle.value = {}\n        }\n      }\n    )\n\n    props.api.modals.push(getModalInfo())\n\n    onMounted(() => {\n      mounted()\n    })\n    onBeforeUnmount(() => {\n      close()\n      props.lockScroll && vfmContainer.value && enableBodyScroll(vfmContainer.value)\n      root?.value?.remove()\n\n      let index = props.api.modals.findIndex(vm => vm.uid === uid)\n\n      props.api.modals.splice(index, 1)\n    })\n    function getModalInfo() {\n      return {\n        uid,\n        props,\n        emit,\n        vfmContainer,\n        vfmContent,\n        vfmResize,\n        vfmOverlayTransition,\n        vfmTransition,\n        getAttachElement,\n        modalStackIndex,\n        visibility,\n        handleLockScroll,\n        $focusTrap,\n        toggle,\n        params\n      }\n    }\n    function mounted() {\n      if (props.modelValue) {\n        emit('_before-open', createModalEvent({ type: '_before-open' }))\n        if (emitEvent('before-open', false)) {\n          rejectToggle('show')\n          return\n        }\n\n        let target = getAttachElement()\n        if (target || props.attach === false) {\n          if (props.attach !== false) {\n            if (root.value) {\n              target.appendChild(root.value)\n            } else {\n              visible.value = true\n              nextTick(() => {\n                mounted()\n              })\n              return\n            }\n          }\n\n          let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n\n          if (index !== -1) {\n            // if this is already exist in modalStack, delete it\n            props.api.openedModals.splice(index, 1)\n          }\n          props.api.openedModals.push(getModalInfo())\n\n          modalStackIndex.value = props.api.openedModals.length - 1\n\n          handleLockScroll()\n\n          props.api.openedModals\n            .filter(vm => vm.uid !== uid)\n            .forEach((vm, index) => {\n              if (vm.getAttachElement() === target) {\n                // if vm and this have the same attach element\n                vm.modalStackIndex.value = index\n                !vm.props.keepOverlay && (vm.visibility.overlay = false)\n              }\n            })\n\n          visible.value = true\n          startTransitionEnter()\n        } else if (target !== false) {\n          console.warn('Unable to locate target '.concat(props.attach))\n        }\n      }\n    }\n    function close() {\n      let index = props.api.openedModals.findIndex(vm => vm.uid === uid)\n      if (index !== -1) {\n        // remove this in modalStack\n        props.api.openedModals.splice(index, 1)\n      }\n      if (props.api.openedModals.length > 0) {\n        // If there are still nested modals opened\n        const $_vm = props.api.openedModals[props.api.openedModals.length - 1]\n        $_vm.props.focusTrap && $_vm.$focusTrap.firstElement().focus()\n        if ($_vm.props.focusRetain || $_vm.props.focusTrap) {\n          $_vm.vfmContainer.value.focus()\n        }\n        !$_vm.props.hideOverlay && ($_vm.visibility.overlay = true)\n      }\n      props.drag && removeDragDown()\n      props.resize && removeResizeDown()\n      _state.value = null\n\n      startTransitionLeave()\n    }\n    function handleLockScroll() {\n      if (props.modelValue) {\n        nextTick(() => {\n          if (props.lockScroll) {\n            disableBodyScroll(vfmContainer.value, {\n              reserveScrollBarGap: true\n            })\n          } else {\n            enableBodyScroll(vfmContainer.value)\n          }\n        })\n      }\n    }\n    function getAttachElement() {\n      let target\n      if (props.attach === false) {\n        target = false\n      } else if (typeof props.attach === 'string') {\n        // CSS selector\n        if (window) {\n          target = window.document.querySelector(props.attach)\n        } else {\n          target = false\n        }\n      } else {\n        // DOM Element\n        target = props.attach\n      }\n      return target\n    }\n    function startTransitionEnter() {\n      visibility.overlay = true\n      visibility.modal = true\n    }\n    function startTransitionLeave() {\n      visibility.overlay = false\n      visibility.modal = false\n    }\n\n    function beforeOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Entering\n    }\n    function afterOverlayEnter() {\n      overlayTransitionState.value = TransitionState.Enter\n    }\n    function beforeOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leaving\n    }\n    function afterOverlayLeave() {\n      overlayTransitionState.value = TransitionState.Leave\n    }\n    function beforeModalEnter() {\n      modalTransitionState.value = TransitionState.Entering\n    }\n    function afterModalEnter() {\n      modalTransitionState.value = TransitionState.Enter\n      if (props.focusRetain || props.focusTrap) {\n        vfmContainer.value.focus()\n      }\n      props.focusTrap && $focusTrap.enable(vfmContainer.value)\n      props.drag && addDragDown()\n      props.resize && addResizeDown()\n\n      emit('_opened')\n      emit('opened', createModalEvent({ type: 'opened' }))\n      resolveToggle('show')\n    }\n    function beforeModalLeave() {\n      modalTransitionState.value = TransitionState.Leaving\n\n      if ($focusTrap.enabled()) {\n        $focusTrap.disable()\n      }\n    }\n    function afterModalLeave() {\n      modalTransitionState.value = TransitionState.Leave\n      modalStackIndex.value = null\n      props.lockScroll && enableBodyScroll(vfmContainer.value)\n      if (!props.keepChangedStyle) {\n        dragResizeStyle.value = {}\n      }\n\n      let stopEvent = false\n      const event = createModalEvent({\n        type: 'closed',\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit('_closed')\n      emit('closed', event)\n      resolveToggle('hide')\n      if (stopEvent) return\n      params.value = {}\n    }\n    function onMousedown(e) {\n      lastMousedownEl.value = e?.target\n    }\n    function onMouseupContainer() {\n      // skip when the lastMousedownEl didn't equal vfmContainer\n      if (lastMousedownEl.value !== vfmContainer.value) return\n      // skip when state equal 'resize:move'\n      if (_state.value === 'resize:move') return\n      emit('click-outside', createModalEvent({ type: 'click-outside' }))\n      props.clickToClose && emit('update:modelValue', false)\n    }\n    function onEsc() {\n      if (visible.value && props.escToClose) {\n        emit('update:modelValue', false)\n      }\n    }\n    function createModalEvent(eventProps = {}) {\n      return {\n        ref: getModalInfo(),\n        ...eventProps\n      }\n    }\n    function emitEvent(eventType, value) {\n      let stopEvent = false\n      const event = createModalEvent({\n        type: eventType,\n        stop() {\n          stopEvent = true\n        }\n      })\n      emit(eventType, event)\n      if (stopEvent) {\n        _stopEvent.value = true\n        nextTick(() => {\n          emit('update:modelValue', value)\n        })\n        return true\n      }\n      return false\n    }\n    function emitState(e, state, action) {\n      _state.value = `${state}:${action}`\n      emit(_state.value, e)\n    }\n    function toggle(show, _params) {\n      return new Promise((resolve, reject) => {\n        resolveToggle = res => {\n          resolve(res)\n          resolveToggle = noop\n        }\n        rejectToggle = err => {\n          reject(err)\n          rejectToggle = noop\n        }\n        const value = typeof show === 'boolean' ? show : !props.modelValue\n        if (value && arguments.length === 2) {\n          params.value = _params\n        }\n        emit('update:modelValue', value)\n      })\n    }\n    function pointerDown(e) {\n      e.stopPropagation()\n      const STATE_RESIZE = 'resize'\n      const STATE_DRAG = 'drag'\n      const direction = e.target.getAttribute('direction')\n      let state\n      if (direction) {\n        state = STATE_RESIZE\n      } else if (validDragElement(e, vfmContent.value, props.dragSelector)) {\n        state = STATE_DRAG\n      } else {\n        return\n      }\n      emitState(e, state, 'start')\n      const down = getPosition(e)\n      const rectContainer = vfmContainer.value.getBoundingClientRect()\n      const rectContent = vfmContent.value.getBoundingClientRect()\n      const isAbsolute = window.getComputedStyle(vfmContent.value).position === 'absolute'\n      const position = {\n        top: trimPx(dragResizeStyle.value.top),\n        left: trimPx(dragResizeStyle.value.left)\n      }\n      const limit = (() => {\n        if (props.fitParent) {\n          const limit = {\n            absolute() {\n              return {\n                minTop: 0,\n                minLeft: 0,\n                maxTop: rectContainer.height - rectContent.height,\n                maxLeft: rectContainer.width - rectContent.width\n              }\n            },\n            relative() {\n              return {\n                minTop: position.top + rectContainer.top - rectContent.top,\n                minLeft: position.left + rectContainer.left - rectContent.left,\n                maxTop: position.top + rectContainer.bottom - rectContent.bottom,\n                maxLeft: position.left + rectContainer.right - rectContent.right\n              }\n            }\n          }\n          return isAbsolute ? limit.absolute() : limit.relative()\n        } else {\n          return {}\n        }\n      })()\n      const resetBodyCursor = state === STATE_RESIZE && setStyle(document.body, 'cursor', resizeCursor[direction])\n\n      const moving = e => {\n        // onPointerMove\n        e.stopPropagation()\n        emitState(e, state, 'move')\n        const move = getPosition(e)\n        let offset = {\n          x: move.x - down.x,\n          y: move.y - down.y\n        }\n        if (state === STATE_RESIZE) {\n          offset = getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute)\n        }\n\n        let top\n        let left\n        if (isAbsolute) {\n          top = rectContent.top - rectContainer.top + offset.y\n          left = rectContent.left - rectContainer.left + offset.x\n        } else {\n          top = position.top + offset.y\n          left = position.left + offset.x\n        }\n        if (state === STATE_DRAG && props.fitParent) {\n          top = clamp(limit.minTop, top, limit.maxTop)\n          left = clamp(limit.minLeft, left, limit.maxLeft)\n        }\n        const style = {\n          position: 'relative',\n          top: top + 'px',\n          left: left + 'px',\n          margin: 'unset',\n          touchAction: 'none',\n          ...(isAbsolute && {\n            position: 'absolute',\n            transform: 'unset',\n            width: rectContent.width + 'px',\n            height: rectContent.height + 'px'\n          }),\n          ...(offset.width && { width: offset.width + 'px' }),\n          ...(offset.height && { height: offset.height + 'px' })\n        }\n\n        dragResizeStyle.value = {\n          ...dragResizeStyle.value,\n          ...style\n        }\n      }\n      const end = e => {\n        // onPointerUp\n        e.stopPropagation()\n        if (state === STATE_RESIZE) {\n          resetBodyCursor && resetBodyCursor()\n        }\n        // Excute onMouseupContainer before trigger emitState\n        setTimeout(() => {\n          emitState(e, state, 'end')\n        })\n        removeListener('move', document, moving)\n        removeListener('up', document, end)\n      }\n      addListener('move', document, moving)\n      addListener('up', document, end)\n    }\n    function addDragDown() {\n      addListener('down', vfmContent.value, pointerDown)\n      dragResizeStyle.value.touchAction = 'none'\n    }\n    function removeDragDown() {\n      removeListener('down', vfmContent.value, pointerDown)\n    }\n    function addResizeDown() {\n      visibility.resize = true\n      nextTick(() => {\n        addListener('down', vfmResize.value, pointerDown)\n      })\n    }\n    function removeResizeDown() {\n      removeListener('down', vfmResize.value, pointerDown)\n      visibility.resize = false\n    }\n    function getResizeOffset(direction, offset, rectContainer, rectContent, isAbsolute) {\n      const setOffset = dir => {\n        let offsetAxis = offset[dir.axis]\n        offsetAxis = props.fitParent ? clamp(dir.min, offsetAxis, dir.max) : offsetAxis\n        let edge = clamp(dir.minEdge, dir.getEdge(offsetAxis), dir.maxEdge)\n        offsetAxis = dir.getOffsetAxis(edge, isAbsolute)\n        return {\n          [dir.edgeName]: edge,\n          [dir.axis]: offsetAxis\n        }\n      }\n\n      const getDirectionInfo = (position, edgeName, axis, isPositive) => {\n        const rectContentEdge = rectContent[edgeName]\n        const positionOffset = rectContainer[position] - rectContent[position]\n        const EdgeName = capitalize(edgeName)\n        return {\n          axis,\n          edgeName,\n          min: isPositive ? positionOffset : -rectContentEdge,\n          max: isPositive ? rectContentEdge : positionOffset,\n          minEdge: props[`min${EdgeName}`],\n          maxEdge: props[`max${EdgeName}`],\n          getEdge: offsetAxis => rectContent[edgeName] - offsetAxis * (isPositive ? 1 : -1),\n          getOffsetAxis: (edge, isAbsolute) => {\n            const offsetAxis = rectContent[edgeName] - edge\n            if (isAbsolute) {\n              return isPositive ? offsetAxis : 0\n            } else {\n              return ((isPositive ? 1 : -1) * offsetAxis) / 2\n            }\n          }\n        }\n      }\n\n      const directions = {\n        t: ['top', 'height', 'y', true],\n        b: ['bottom', 'height', 'y', false],\n        l: ['left', 'width', 'x', true],\n        r: ['right', 'width', 'x', false]\n      }\n\n      let _offset = { x: 0, y: 0 }\n      direction.split('').forEach(dir => {\n        const directionInfo = getDirectionInfo(...directions[dir])\n        _offset = {\n          ..._offset,\n          ...setOffset(directionInfo)\n        }\n      })\n      return _offset\n    }\n    return {\n      root,\n      vfmContainer,\n      vfmContent,\n      vfmResize,\n      vfmOverlayTransition,\n      vfmTransition,\n      computedOverlayTransition,\n      computedTransition,\n      visible,\n      visibility,\n      params,\n      calculateZIndex,\n      bindStyle,\n      bindContentStyle,\n      beforeOverlayEnter,\n      afterOverlayEnter,\n      beforeOverlayLeave,\n      afterOverlayLeave,\n      beforeModalEnter,\n      afterModalEnter,\n      beforeModalLeave,\n      afterModalLeave,\n      onMousedown,\n      onMouseupContainer,\n      onEsc\n    }\n  }\n}\n</script>\n\n<style lang=\"css\" scoped>\n.vfm--fixed {\n  position: fixed;\n}\n.vfm--absolute {\n  position: absolute;\n}\n.vfm--inset {\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.vfm--overlay {\n  background-color: rgba(0, 0, 0, 0.5);\n}\n.vfm--prevent-none {\n  pointer-events: none;\n}\n.vfm--prevent-auto {\n  pointer-events: auto;\n}\n.vfm--outline-none:focus {\n  outline: none;\n}\n.vfm-enter-active,\n.vfm-leave-active {\n  transition: opacity 0.2s;\n}\n.vfm-enter-from,\n.vfm-leave-to {\n  opacity: 0;\n}\n\n.vfm--touch-none {\n  touch-action: none;\n}\n.vfm--select-none {\n  user-select: none;\n}\n\n.vfm--resize-tr,\n.vfm--resize-br,\n.vfm--resize-bl,\n.vfm--resize-tl {\n  width: 12px;\n  height: 12px;\n  z-index: 10;\n}\n\n.vfm--resize-t {\n  top: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-tr {\n  top: -6px;\n  right: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-r {\n  top: 0;\n  right: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-br {\n  bottom: -6px;\n  right: -6px;\n  cursor: nwse-resize;\n}\n.vfm--resize-b {\n  bottom: -6px;\n  left: 0;\n  width: 100%;\n  height: 12px;\n  cursor: ns-resize;\n}\n.vfm--resize-bl {\n  bottom: -6px;\n  left: -6px;\n  cursor: nesw-resize;\n}\n.vfm--resize-l {\n  top: 0;\n  left: -6px;\n  width: 12px;\n  height: 100%;\n  cursor: ew-resize;\n}\n.vfm--resize-tl {\n  top: -6px;\n  left: -6px;\n  cursor: nwse-resize;\n}\n</style>\n","function styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nexport default styleInject;\n","<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  methods: {\n    slice(index) {\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n","<template>\n  <div class=\"modals-container\">\n    <component\n      :is=\"modal.component\"\n      v-for=\"(modal, index) in api.dynamicModals\"\n      :key=\"modal.id\"\n      v-bind=\"modal.bind\"\n      v-model=\"modal.value\"\n      v-on=\"modal.on\"\n      @_closed=\"slice(index)\"\n      @_beforeOpen=\"e => beforeOpen(e, modal)\"\n      @_opened=\"modal.opened\"\n    >\n      <template v-for=\"(slot, key) in modal.slots\" #[key] :key=\"key\">\n        <!-- eslint-disable vue/no-v-html -->\n        <div v-if=\"isString(slot)\" v-html=\"slot\"></div>\n        <component :is=\"slot.component\" v-else v-bind=\"slot.bind\" v-on=\"slot.on || {}\" />\n      </template>\n    </component>\n  </div>\n</template>\n\n<script>\nexport default {\n  props: {},\n  methods: {\n    slice(index) {\n      this.api.dynamicModals.splice(index, 1)\n    },\n    async beforeOpen(e, modal, index) {\n      e.ref.params.value = modal.params\n      await this.$nextTick()\n      await this.$nextTick()\n      if (!modal.value) {\n        this.slice(index)\n        modal.reject('show')\n      }\n    },\n    isString(val) {\n      return typeof val === 'string'\n    }\n  }\n}\n</script>\n","import VueFinalModal from './VueFinalModal.vue'\nimport ModalsContainer from './ModalsContainer.vue'\nimport { shallowReactive } from 'vue'\n\nexport function defineApi() {\n  let _modalComponent = null\n\n  return {\n    show(modal, ...args) {\n      switch (typeof modal) {\n        case 'string':\n          return this.toggle(modal, true, ...args)\n        case 'object': {\n          return Promise.allSettled([\n            new Promise((resolve, reject) => {\n              const defaultModal = {\n                value: true,\n                id: Symbol('dynamicModal'),\n                component: _modalComponent,\n                bind: {},\n                slots: {},\n                on: {},\n                params: args[0],\n                reject,\n                opened() {\n                  resolve('show')\n                }\n              }\n              this.dynamicModals.push(shallowReactive(Object.assign(defaultModal, modal)))\n            })\n          ])\n        }\n      }\n    },\n    hide(...names) {\n      return this.toggle(names, false)\n    },\n    hideAll() {\n      return this.hide(...this.openedModals.map(modal => modal.props.name))\n    },\n    toggle(name, ...args) {\n      const modals = Array.isArray(name) ? this.get(...name) : this.get(name)\n      return Promise.allSettled(modals.map(modal => modal.toggle(...args)))\n    },\n    get(...names) {\n      return this.modals.filter(modal => names.includes(modal.props.name))\n    },\n    dynamicModals: shallowReactive([]),\n    openedModals: [],\n    modals: [],\n    _setDefaultModal(modalComponent) {\n      _modalComponent = modalComponent\n    }\n  }\n}\n\nfunction bindApi(component, api) {\n  const _component = { ...component, props: { ...component.props } }\n  Object.assign(_component.props, {\n    api: { type: Object, default: () => api }\n  })\n  return _component\n}\n\nexport function defineModal(api) {\n  const modalComponent = bindApi(VueFinalModal, api)\n  api._setDefaultModal(modalComponent)\n  return modalComponent\n}\n\nexport function defineContainer(api) {\n  return bindApi(ModalsContainer, api)\n}\n","import { defineApi, defineModal, defineContainer } from './PluginCore'\n\n/**\n * @description Ensure that `_vfm` is used when function `installPlugin` is executed for the first time\n */\nlet _count = 0\n\nconst _key = '$vfm'\nconst _componentName = 'VueFinalModal'\nconst _dynamicContainerName = 'ModalsContainer'\n\n/**\n * @description Support create multiple vfm instance\n */\nexport const defineVfm = () => {\n  let api = defineApi()\n  return {\n    [_key]: api,\n    [_componentName]: defineModal(api),\n    [_dynamicContainerName]: defineContainer(api)\n  }\n}\n\n/**\n * @description Create a vfm instance by default for directly support `import { $vfm, VueFinalModal, ModalsContainer } from 'vue-final-modal'`\n */\nconst _vfm = defineVfm()\nexport const { $vfm, VueFinalModal, ModalsContainer } = _vfm\n\n/**\n * @description Register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nconst installVfm = (App, options = {}) => {\n  const { $vfm, VueFinalModal, ModalsContainer } = _count === 0 ? _vfm : defineVfm()\n  _count += 1\n  const key = options.key || _key\n  const componentName = options.componentName || _componentName\n  const dynamicContainerName = options.dynamicContainerName || _dynamicContainerName\n  Object.defineProperty(App.config.globalProperties, key, {\n    get() {\n      return $vfm\n    }\n  })\n  App.provide(key, $vfm)\n  App.component(componentName, VueFinalModal)\n  App.component(dynamicContainerName, ModalsContainer)\n}\n\n/**\n * @description Vue plugin for register vfm instance globally\n * @deprecated not available in vue-final-modal 4\n */\nexport const vfmPlugin = pluginOptions => ({\n  install(App, options) {\n    const _options = Object.assign({}, pluginOptions, options)\n    installVfm(App, _options)\n  }\n})\n\nvfmPlugin.install = installVfm\n"],"names":["queryFocusableElements","element","selector","querySelectorAll","isFocused","document","activeElement","FocusTrap","_classCallCheck","this","root","elements","onKeyDown","bind","enable","disable","firstElement","lastElement","length","event","key","keyCode","isTabPressed","shiftKey","focus","preventDefault","addEventListener","removeEventListener","getPosition","e","targetTouches","x","clientX","y","clientY","clamp","min","num","max","Math","trimPx","distance","Number","replace","pointerType","down","pc","m","move","up","addListener","type","el","callback","passive","removeListener","hasPassiveEvents","window","passiveTestOptions","previousBodyOverflowSetting","previousBodyPaddingRight","isIosDevice","navigator","platform","test","maxTouchPoints","locks","documentListenerAdded","initialClientY","hasAnyScrollableEl","delta","path","push","classList","contains","parentElement","composedPath","forEach","nodeType","Node","ELEMENT_NODE","style","getComputedStyle","includes","overflowY","scrollHeight","clientHeight","hasScrollbar","scrollTop","shouldScroll","allowTouchMove","some","rawEvent","target","touches","disableBodyScroll","targetElement","options","lock","ontouchstart","ontouchmove","isTargetElementTotallyScrolled","stopPropagation","handleScroll","undefined","reserveScrollBarGap","scrollBarGap","innerWidth","documentElement","clientWidth","computedBodyPaddingRight","parseInt","body","getPropertyValue","paddingRight","overflow","setOverflowHidden","console","error","enableBodyScroll","filter","noop","TransitionState","resizeCursor","t","tr","r","br","b","bl","l","tl","props","name","String","default","modelValue","Boolean","ssr","classes","Object","Array","overlayClass","contentClass","styles","overlayStyle","contentStyle","lockScroll","hideOverlay","clickToClose","escToClose","preventClick","attach","validator","val","transition","overlayTransition","keepOverlay","zIndexAuto","zIndexBase","zIndex","focusRetain","focusTrap","fitParent","drag","dragSelector","keepChangedStyle","resize","resizeDirections","value","indexOf","minWidth","minHeight","maxWidth","Infinity","maxHeight","emits","setup","emit","uid","Symbol","ref","vfmContainer","vfmContent","vfmResize","vfmOverlayTransition","vfmTransition","modalStackIndex","$focusTrap","visible","visibility","reactive","modal","overlay","overlayTransitionState","modalTransitionState","_stopEvent","params","dragResizeStyle","_state","lastMousedownEl","resolveToggle","rejectToggle","computedOverlayTransition","computed","computedTransition","isComponentReadyToBeDestroyed","calculateZIndex","bindStyle","bindContentStyle","isArray","getModalInfo","getAttachElement","handleLockScroll","toggle","mounted","createModalEvent","emitEvent","nextTick","appendChild","index","api","openedModals","findIndex","vm","splice","warn","concat","close","$_vm","removeDragDown","removeResizeDown","querySelector","eventProps","eventType","stopEvent","stop","emitState","state","action","show","_params","Promise","resolve","reject","res","err","arguments","pointerDown","STATE_RESIZE","STATE_DRAG","direction","getAttribute","validDragElement","cacheStyle","rectContainer","getBoundingClientRect","rectContent","isAbsolute","position","top","left","limit","absolute","minTop","minLeft","maxTop","height","maxLeft","width","relative","bottom","right","resetBodyCursor","moving","offset","setOffset","dir","offsetAxis","axis","edge","minEdge","getEdge","maxEdge","getOffsetAxis","edgeName","getDirectionInfo","isPositive","s","rectContentEdge","positionOffset","EdgeName","charAt","toUpperCase","slice","directions","_offset","split","directionInfo","getResizeOffset","margin","touchAction","transform","end","setTimeout","addDragDown","addResizeDown","watch","display","flush","modals","onMounted","onBeforeUnmount","remove","beforeOverlayEnter","afterOverlayEnter","beforeOverlayLeave","afterOverlayLeave","beforeModalEnter","afterModalEnter","beforeModalLeave","enabled","afterModalLeave","onMousedown","onMouseupContainer","onEsc","class","css","insertAt","head","getElementsByTagName","createElement","firstChild","insertBefore","styleSheet","cssText","createTextNode","$props","$setup","_createElementBlock","onKeydown","_createVNode","_mergeProps","onBeforeEnter","onAfterEnter","onBeforeLeave","onAfterLeave","persisted","_createElementVNode","aria-expanded","toString","role","aria-modal","tabindex","onMouseup","_renderSlot","_ctx","_hoisted_2","methods","dynamicModals","beforeOpen","_this","$nextTick","isString","bindApi","component","_component","assign","_hoisted_1","_createBlock","id","_toHandlers","on","on_closed","$options","on_beforeOpen","on_opened","opened","slots","slot","_createCommentVNode","innerHTML","_count","defineVfm","_modalComponent","args","allSettled","defaultModal","shallowReactive","hide","names","hideAll","map","get","_setDefaultModal","modalComponent","VueFinalModal","defineModal","ModalsContainer","defineContainer","_vfm","$vfm","installVfm","App","componentName","dynamicContainerName","defineProperty","config","globalProperties","provide","vfmPlugin","pluginOptions","install","_options"],"mappings":"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"}